/*
 * iperf, Copyright (c) 2014-2019, The Regents of the University of
 * California, through Lawrence Berkeley National Laboratory (subject
 * to receipt of any required approvals from the U.S. Dept. of
 * Energy).  All rights reserved.
 *
 * If you have questions about your rights to use or distribute this
 * software, please contact Berkeley Lab's Technology Transfer
 * Department at TTD@lbl.gov.
 *
 * NOTICE.  This software is owned by the U.S. Department of Energy.
 * As such, the U.S. Government has been granted for itself and others
 * acting on its behalf a paid-up, nonexclusive, irrevocable,
 * worldwide license in the Software to reproduce, prepare derivative
 * works, and perform publicly and display publicly.  Beginning five
 * (5) years after the date permission to assert copyright is obtained
 * from the U.S. Department of Energy, and subject to any subsequent
 * five (5) year renewals, the U.S. Government is granted for itself
 * and others acting on its behalf a paid-up, nonexclusive,
 * irrevocable, worldwide license in the Software to reproduce,
 * prepare derivative works, distribute copies to the public, perform
 * publicly and display publicly, and to permit others to do so.
 *
 * This code is distributed under a BSD style license, see the LICENSE
 * file for complete information.
 */
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/time.h>
#include <sys/select.h>
#include <limits.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

#include "iperf.h"
#include "iperf_api.h"
#include "iperf_tcp.h"
#include "net.h"
#include "cjson.h"

#if defined(HAVE_FLOWLABEL)
#include "flowlabel.h"
#endif /* HAVE_FLOWLABEL */


unsigned char key_der[] = {
  0x30, 0x82, 0x04, 0xa4, 0x02, 0x01, 0x00, 0x02, 0x82, 0x01, 0x01, 0x00,
  0xb0, 0xe3, 0x48, 0xf0, 0xe5, 0xa2, 0x67, 0xa9, 0x1c, 0x2c, 0xdb, 0xc3,
  0x83, 0x14, 0xae, 0xab, 0x90, 0x01, 0x4d, 0x31, 0x4d, 0x5e, 0x3f, 0x36,
  0x96, 0xf6, 0xee, 0x4f, 0x48, 0xe5, 0x34, 0x55, 0x4e, 0x32, 0x28, 0x3a,
  0xcf, 0xf9, 0x84, 0xd2, 0x36, 0x2c, 0xf1, 0x56, 0x7b, 0x80, 0x91, 0x13,
  0x1d, 0x3d, 0x66, 0xb4, 0xfc, 0x2b, 0x73, 0x45, 0x38, 0x1a, 0x12, 0xcb,
  0xb6, 0xe1, 0x3c, 0x0b, 0x23, 0x19, 0xa1, 0x71, 0x09, 0x86, 0x16, 0x73,
  0xdb, 0x62, 0x5f, 0x59, 0xb9, 0x82, 0xad, 0xd3, 0xa1, 0x54, 0x52, 0x99,
  0xb6, 0x7a, 0xe5, 0xf1, 0x37, 0x92, 0xf9, 0xc8, 0xf0, 0x4f, 0xdd, 0xe5,
  0x5c, 0xb3, 0x03, 0x43, 0x8c, 0x99, 0x66, 0xdf, 0x6a, 0x89, 0x41, 0x49,
  0x33, 0x28, 0x5a, 0x0a, 0x91, 0xca, 0x71, 0x1a, 0x4f, 0xec, 0xf5, 0x12,
  0x1d, 0xb2, 0x0d, 0x3c, 0xd5, 0x17, 0x2f, 0x5e, 0xa2, 0xfd, 0x43, 0x75,
  0x01, 0x54, 0xa8, 0x60, 0xea, 0x6c, 0x7e, 0x5b, 0x41, 0x8b, 0xd3, 0x63,
  0x91, 0x72, 0x7a, 0x6e, 0xd4, 0x70, 0xa5, 0x80, 0x7b, 0x6c, 0x92, 0xd2,
  0x3d, 0xc7, 0xe1, 0xd5, 0x6d, 0x54, 0x12, 0x8d, 0x63, 0xba, 0x95, 0xdc,
  0xfc, 0x74, 0xf3, 0x21, 0x80, 0xb3, 0x97, 0xd0, 0x16, 0x05, 0x30, 0x87,
  0x20, 0x79, 0xfa, 0xac, 0x21, 0xbe, 0x47, 0x8b, 0x25, 0xd8, 0x1a, 0xa4,
  0x66, 0x92, 0x4f, 0x02, 0xe0, 0xa1, 0x02, 0x96, 0x1d, 0xb7, 0xbf, 0x94,
  0x0d, 0xcd, 0x88, 0x12, 0x01, 0xf6, 0x1c, 0xe7, 0x15, 0x41, 0x8a, 0xa3,
  0x78, 0x66, 0x9e, 0x20, 0x2f, 0x61, 0x96, 0xeb, 0x41, 0xc9, 0xf7, 0xb5,
  0xcd, 0x25, 0xfc, 0x9e, 0x08, 0xdf, 0xdb, 0xf6, 0x3e, 0x6d, 0xbd, 0x14,
  0x0c, 0xa3, 0x5a, 0xf4, 0x32, 0x06, 0x41, 0xa4, 0xb7, 0x3d, 0xaa, 0xe1,
  0xe9, 0x4e, 0x65, 0x89, 0x02, 0x03, 0x01, 0x00, 0x01, 0x02, 0x82, 0x01,
  0x00, 0x1f, 0x4a, 0xf6, 0x3a, 0x77, 0xc5, 0x75, 0x65, 0x3b, 0x70, 0xcc,
  0x28, 0x18, 0x66, 0x6e, 0x48, 0x37, 0x9f, 0xa3, 0x52, 0x57, 0x87, 0x96,
  0xd3, 0x47, 0x7d, 0xc3, 0xc7, 0x0e, 0xf4, 0x4d, 0x7f, 0xd1, 0xe7, 0x99,
  0xaa, 0x5d, 0xe4, 0x9c, 0x94, 0xbb, 0xb4, 0xd3, 0xb5, 0x23, 0x00, 0x29,
  0xaa, 0x22, 0x00, 0x1c, 0xcd, 0x63, 0xd7, 0x23, 0xfb, 0x58, 0xe3, 0x73,
  0xf3, 0xca, 0x14, 0xaa, 0x94, 0xa5, 0xcf, 0x00, 0xfa, 0x88, 0x5e, 0xca,
  0x56, 0x10, 0xb7, 0xa4, 0x7a, 0xb1, 0x10, 0xe7, 0x43, 0x8b, 0x44, 0xe9,
  0x9f, 0xfb, 0xe2, 0x5e, 0x0f, 0x80, 0x6f, 0x65, 0xf5, 0x20, 0x5e, 0x60,
  0xb9, 0x14, 0xdf, 0x2e, 0x72, 0xa2, 0xca, 0xf8, 0xa2, 0x09, 0xac, 0xe2,
  0x79, 0xda, 0xad, 0x06, 0xd0, 0xdb, 0xdd, 0xde, 0x88, 0x73, 0x1f, 0x4e,
  0x73, 0xb8, 0x01, 0x29, 0xca, 0x5b, 0x40, 0x50, 0xc6, 0xb7, 0xef, 0xb0,
  0x48, 0xe6, 0xf9, 0x2f, 0xec, 0x61, 0x46, 0x6f, 0x41, 0xe4, 0x1e, 0x25,
  0xff, 0xa6, 0xf2, 0x8a, 0x48, 0x8f, 0x78, 0xaa, 0x88, 0x2b, 0x9b, 0x42,
  0x4a, 0x83, 0xfd, 0x66, 0xbd, 0x66, 0xbe, 0x93, 0x68, 0x1a, 0x6d, 0x4f,
  0xe0, 0xbb, 0xc4, 0xba, 0x71, 0x49, 0x71, 0x10, 0x6a, 0x54, 0x8d, 0x35,
  0xd1, 0x53, 0x70, 0x7c, 0xef, 0x4f, 0xf7, 0xca, 0x15, 0xcb, 0x32, 0x6e,
  0xf7, 0xf1, 0x59, 0x66, 0xb4, 0x31, 0x5e, 0x86, 0x3d, 0x25, 0xd5, 0xc5,
  0x38, 0xce, 0xa7, 0x6e, 0x5f, 0xa1, 0x30, 0x33, 0x37, 0x4e, 0x41, 0x0e,
  0x75, 0xaf, 0x4d, 0xbc, 0x18, 0x48, 0x9a, 0x8c, 0xc4, 0x02, 0xfb, 0x9c,
  0xf7, 0xb0, 0x9a, 0x69, 0x7c, 0x91, 0xdd, 0x78, 0xaf, 0xc4, 0xca, 0x8d,
  0xa8, 0xd2, 0x1b, 0xe3, 0xeb, 0x32, 0x50, 0xf6, 0xb6, 0x3c, 0x24, 0xb7,
  0x67, 0x3b, 0x48, 0xe6, 0xa1, 0x02, 0x81, 0x81, 0x00, 0xd6, 0x06, 0xd5,
  0x1b, 0xa8, 0x9f, 0xa6, 0xfa, 0x5b, 0x06, 0x40, 0xcf, 0x8b, 0x72, 0x26,
  0xf1, 0xf3, 0x37, 0x17, 0xb1, 0x4b, 0x2e, 0xb4, 0x1c, 0xe3, 0xc1, 0x5d,
  0x16, 0x37, 0x4c, 0xbc, 0x38, 0x47, 0x0f, 0xd9, 0x55, 0x2a, 0xe7, 0x03,
  0x51, 0xa6, 0xbc, 0x3c, 0x5f, 0x5d, 0x6d, 0xbb, 0xe5, 0xbb, 0x67, 0x30,
  0x33, 0x27, 0xc1, 0x38, 0xa4, 0xae, 0x59, 0xa5, 0xf1, 0x47, 0x14, 0x6c,
  0x8a, 0xa8, 0x8f, 0x99, 0x3b, 0xa7, 0x4b, 0x53, 0x2f, 0x3f, 0x34, 0x1c,
  0x4a, 0xb1, 0xb0, 0x52, 0xb2, 0xf6, 0x02, 0x88, 0x06, 0xb9, 0xc9, 0xfa,
  0xf8, 0xda, 0xcb, 0x41, 0xfe, 0x4f, 0xe0, 0x7e, 0x48, 0xa6, 0x40, 0xd0,
  0xf6, 0x28, 0x77, 0xcf, 0x08, 0xce, 0xeb, 0x12, 0x85, 0x2b, 0x55, 0x9e,
  0x62, 0x76, 0x29, 0x1c, 0xcf, 0x2a, 0x50, 0x1b, 0x65, 0xea, 0xad, 0x18,
  0x17, 0x25, 0x41, 0x3e, 0xed, 0x02, 0x81, 0x81, 0x00, 0xd3, 0x93, 0xe7,
  0x4a, 0xd5, 0x80, 0xe0, 0x3e, 0xd5, 0x49, 0xb3, 0x67, 0x56, 0x2e, 0xa5,
  0xbc, 0x5c, 0x84, 0x39, 0x4b, 0x13, 0xac, 0xad, 0xef, 0xe3, 0x5f, 0x79,
  0xf7, 0xc4, 0xc5, 0x8a, 0xae, 0x1e, 0x5c, 0xba, 0xba, 0x69, 0x5f, 0x3f,
  0x09, 0x06, 0x33, 0x2a, 0xc4, 0xb3, 0xa0, 0x6f, 0x9a, 0x39, 0x98, 0x57,
  0x2e, 0x2f, 0xb4, 0xbb, 0x24, 0xf9, 0x70, 0xdc, 0xd4, 0x71, 0x76, 0x21,
  0x4e, 0xc5, 0xb5, 0x84, 0x0f, 0xe9, 0x36, 0x13, 0x1f, 0xc4, 0xca, 0xd8,
  0x88, 0x1d, 0x71, 0xd7, 0x8c, 0xe5, 0x2e, 0x9d, 0x96, 0x44, 0x68, 0x38,
  0xbd, 0xdf, 0xfe, 0x4b, 0x15, 0xfa, 0x77, 0xd6, 0x1d, 0xdd, 0xa7, 0x17,
  0xed, 0x0c, 0xcf, 0x2a, 0x07, 0x43, 0x89, 0xc5, 0xec, 0xf5, 0x03, 0x7c,
  0xa3, 0x32, 0x4e, 0x20, 0x22, 0xaf, 0x35, 0xb5, 0x08, 0xe7, 0x70, 0x09,
  0x74, 0x04, 0xd5, 0x11, 0x8d, 0x02, 0x81, 0x81, 0x00, 0xc2, 0xfa, 0x46,
  0x7a, 0x84, 0x0b, 0xad, 0xda, 0xb5, 0xc1, 0xe4, 0x99, 0x2e, 0xb8, 0x37,
  0xb2, 0x83, 0x97, 0xd5, 0x05, 0xb7, 0x30, 0x3c, 0xf5, 0x74, 0xa7, 0x5b,
  0x5e, 0x39, 0xd2, 0xb6, 0x45, 0xae, 0xb7, 0x49, 0x8e, 0xc5, 0x1e, 0xdf,
  0x6f, 0x2b, 0x2e, 0xa0, 0xf1, 0x5f, 0xf3, 0xf0, 0x11, 0x41, 0xc0, 0xa7,
  0xb0, 0x72, 0xaf, 0x1c, 0x23, 0x2a, 0x92, 0x91, 0x12, 0x55, 0x66, 0xcd,
  0xdb, 0x23, 0xe4, 0x6d, 0xfc, 0x62, 0x53, 0xc4, 0xdc, 0x6d, 0xff, 0xd3,
  0x26, 0x58, 0xea, 0x00, 0xec, 0xf8, 0x21, 0x26, 0x3a, 0xba, 0x56, 0xbf,
  0x44, 0xa6, 0x4e, 0x35, 0x38, 0xb1, 0x1c, 0x1a, 0xef, 0xa4, 0x45, 0xb8,
  0x18, 0x08, 0x95, 0xdd, 0x0e, 0x71, 0x32, 0xc6, 0x14, 0x7b, 0x7d, 0xec,
  0x64, 0x56, 0xb0, 0xed, 0x85, 0xed, 0x4e, 0x3d, 0x27, 0x83, 0xbb, 0x5d,
  0x0e, 0xf8, 0xe9, 0x8f, 0xa1, 0x02, 0x81, 0x81, 0x00, 0xa4, 0x77, 0x54,
  0x53, 0xd7, 0xa3, 0x56, 0xad, 0x81, 0x1e, 0xc9, 0x56, 0x8a, 0xa7, 0xb8,
  0x2d, 0xb3, 0xbd, 0x14, 0xcc, 0x47, 0x7e, 0xf3, 0xb6, 0x86, 0x08, 0xb1,
  0xc6, 0xe8, 0x2e, 0xa6, 0x9e, 0xb2, 0xfb, 0x62, 0x2b, 0x85, 0xbd, 0x84,
  0x42, 0x7f, 0x8f, 0x46, 0xaf, 0xa0, 0xf2, 0x15, 0xce, 0xcc, 0xf6, 0x9e,
  0xce, 0x48, 0x47, 0x35, 0x32, 0x88, 0xb4, 0x32, 0xf4, 0xf1, 0x3d, 0xe2,
  0xa6, 0x59, 0x09, 0xc0, 0x9e, 0x9d, 0xaa, 0x6b, 0x33, 0x46, 0xc6, 0x67,
  0x8b, 0x67, 0x58, 0x17, 0x36, 0x6e, 0xf0, 0xcd, 0x8f, 0x01, 0x9e, 0x02,
  0x7d, 0x96, 0xa1, 0x15, 0xbc, 0xff, 0xf6, 0x27, 0x7b, 0x0f, 0xd1, 0xd3,
  0xc7, 0x71, 0x2d, 0x98, 0x7e, 0x0d, 0x02, 0x0b, 0xd9, 0x26, 0x9c, 0x8f,
  0x46, 0x4c, 0xd4, 0x6e, 0x26, 0x88, 0x0c, 0x37, 0xad, 0xb4, 0x3a, 0x63,
  0x1e, 0xcc, 0xa2, 0xd4, 0x01, 0x02, 0x81, 0x80, 0x0f, 0x2e, 0xf8, 0xc1,
  0xcd, 0x08, 0xf8, 0x90, 0xf1, 0x7c, 0x66, 0x8f, 0x69, 0x40, 0x45, 0x1c,
  0xcf, 0x8a, 0x66, 0xba, 0x94, 0x55, 0x7e, 0xfd, 0xda, 0x45, 0xf8, 0xe7,
  0x6a, 0x10, 0xca, 0xe2, 0xa6, 0x47, 0x11, 0xe3, 0xc3, 0x46, 0x3f, 0x89,
  0x5b, 0xba, 0x73, 0x6b, 0x2a, 0xec, 0xd5, 0xdc, 0x8d, 0xf5, 0x02, 0xc1,
  0xf2, 0x94, 0xdc, 0xe3, 0x6e, 0x33, 0xed, 0xff, 0x0c, 0x07, 0x79, 0x65,
  0x08, 0x80, 0x8d, 0xfa, 0x88, 0x6c, 0xf0, 0x24, 0x7f, 0x79, 0x6d, 0x0d,
  0x12, 0x86, 0xc4, 0xf6, 0x57, 0x43, 0x39, 0xea, 0x02, 0xaf, 0x55, 0x61,
  0x36, 0x13, 0x52, 0x6e, 0xb3, 0x75, 0x89, 0x9f, 0x14, 0xe2, 0x82, 0xe4,
  0x45, 0x33, 0x1a, 0x0c, 0xa9, 0x15, 0x9e, 0x01, 0x9f, 0x7e, 0xf8, 0xc6,
  0x8b, 0xfa, 0xb4, 0xb4, 0xe5, 0x3b, 0x84, 0x97, 0x59, 0x3a, 0xa3, 0x65,
  0x93, 0x62, 0x1a, 0x86
};
unsigned int key_der_len = 1192;

unsigned char cert_der[] = {
  0x30, 0x82, 0x03, 0x7b, 0x30, 0x82, 0x02, 0x63, 0xa0, 0x03, 0x02, 0x01,
  0x02, 0x02, 0x09, 0x00, 0xf3, 0x0c, 0x36, 0x86, 0xcd, 0x73, 0x36, 0x94,
  0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
  0x04, 0x05, 0x00, 0x30, 0x74, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55,
  0x04, 0x03, 0x13, 0x0a, 0x4d, 0x79, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20,
  0x43, 0x41, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,
  0x02, 0x48, 0x5a, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,
  0x13, 0x02, 0x43, 0x4e, 0x31, 0x1c, 0x30, 0x1a, 0x06, 0x09, 0x2a, 0x86,
  0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x01, 0x16, 0x0d, 0x74, 0x65, 0x73,
  0x74, 0x40, 0x63, 0x65, 0x72, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x31, 0x25,
  0x30, 0x23, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x1c, 0x52, 0x6f, 0x6f,
  0x74, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74,
  0x69, 0x6f, 0x6e, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74,
  0x79, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x36, 0x31, 0x31, 0x31, 0x35, 0x30,
  0x35, 0x30, 0x34, 0x31, 0x38, 0x5a, 0x17, 0x0d, 0x31, 0x39, 0x31, 0x31,
  0x31, 0x35, 0x30, 0x35, 0x30, 0x34, 0x31, 0x38, 0x5a, 0x30, 0x74, 0x31,
  0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x0a, 0x4d, 0x79,
  0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x43, 0x41, 0x31, 0x0b, 0x30, 0x09,
  0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x02, 0x48, 0x5a, 0x31, 0x0b, 0x30,
  0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43, 0x4e, 0x31, 0x1c,
  0x30, 0x1a, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09,
  0x01, 0x16, 0x0d, 0x74, 0x65, 0x73, 0x74, 0x40, 0x63, 0x65, 0x72, 0x74,
  0x2e, 0x63, 0x6f, 0x6d, 0x31, 0x25, 0x30, 0x23, 0x06, 0x03, 0x55, 0x04,
  0x0a, 0x13, 0x1c, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x43, 0x65, 0x72, 0x74,
  0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x41, 0x75,
  0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x30, 0x82, 0x01, 0x22, 0x30,
  0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01,
  0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02,
  0x82, 0x01, 0x01, 0x00, 0xb0, 0xe3, 0x48, 0xf0, 0xe5, 0xa2, 0x67, 0xa9,
  0x1c, 0x2c, 0xdb, 0xc3, 0x83, 0x14, 0xae, 0xab, 0x90, 0x01, 0x4d, 0x31,
  0x4d, 0x5e, 0x3f, 0x36, 0x96, 0xf6, 0xee, 0x4f, 0x48, 0xe5, 0x34, 0x55,
  0x4e, 0x32, 0x28, 0x3a, 0xcf, 0xf9, 0x84, 0xd2, 0x36, 0x2c, 0xf1, 0x56,
  0x7b, 0x80, 0x91, 0x13, 0x1d, 0x3d, 0x66, 0xb4, 0xfc, 0x2b, 0x73, 0x45,
  0x38, 0x1a, 0x12, 0xcb, 0xb6, 0xe1, 0x3c, 0x0b, 0x23, 0x19, 0xa1, 0x71,
  0x09, 0x86, 0x16, 0x73, 0xdb, 0x62, 0x5f, 0x59, 0xb9, 0x82, 0xad, 0xd3,
  0xa1, 0x54, 0x52, 0x99, 0xb6, 0x7a, 0xe5, 0xf1, 0x37, 0x92, 0xf9, 0xc8,
  0xf0, 0x4f, 0xdd, 0xe5, 0x5c, 0xb3, 0x03, 0x43, 0x8c, 0x99, 0x66, 0xdf,
  0x6a, 0x89, 0x41, 0x49, 0x33, 0x28, 0x5a, 0x0a, 0x91, 0xca, 0x71, 0x1a,
  0x4f, 0xec, 0xf5, 0x12, 0x1d, 0xb2, 0x0d, 0x3c, 0xd5, 0x17, 0x2f, 0x5e,
  0xa2, 0xfd, 0x43, 0x75, 0x01, 0x54, 0xa8, 0x60, 0xea, 0x6c, 0x7e, 0x5b,
  0x41, 0x8b, 0xd3, 0x63, 0x91, 0x72, 0x7a, 0x6e, 0xd4, 0x70, 0xa5, 0x80,
  0x7b, 0x6c, 0x92, 0xd2, 0x3d, 0xc7, 0xe1, 0xd5, 0x6d, 0x54, 0x12, 0x8d,
  0x63, 0xba, 0x95, 0xdc, 0xfc, 0x74, 0xf3, 0x21, 0x80, 0xb3, 0x97, 0xd0,
  0x16, 0x05, 0x30, 0x87, 0x20, 0x79, 0xfa, 0xac, 0x21, 0xbe, 0x47, 0x8b,
  0x25, 0xd8, 0x1a, 0xa4, 0x66, 0x92, 0x4f, 0x02, 0xe0, 0xa1, 0x02, 0x96,
  0x1d, 0xb7, 0xbf, 0x94, 0x0d, 0xcd, 0x88, 0x12, 0x01, 0xf6, 0x1c, 0xe7,
  0x15, 0x41, 0x8a, 0xa3, 0x78, 0x66, 0x9e, 0x20, 0x2f, 0x61, 0x96, 0xeb,
  0x41, 0xc9, 0xf7, 0xb5, 0xcd, 0x25, 0xfc, 0x9e, 0x08, 0xdf, 0xdb, 0xf6,
  0x3e, 0x6d, 0xbd, 0x14, 0x0c, 0xa3, 0x5a, 0xf4, 0x32, 0x06, 0x41, 0xa4,
  0xb7, 0x3d, 0xaa, 0xe1, 0xe9, 0x4e, 0x65, 0x89, 0x02, 0x03, 0x01, 0x00,
  0x01, 0xa3, 0x10, 0x30, 0x0e, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,
  0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06, 0x09, 0x2a,
  0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x04, 0x05, 0x00, 0x03, 0x82,
  0x01, 0x01, 0x00, 0x24, 0x22, 0x7e, 0xf7, 0xba, 0x1a, 0x7b, 0xf1, 0x5c,
  0x38, 0xb6, 0xcf, 0xa6, 0x30, 0xa9, 0x51, 0x09, 0xd6, 0xa9, 0x8c, 0x9d,
  0x81, 0x20, 0xa1, 0x81, 0xa9, 0x64, 0x64, 0xdb, 0xeb, 0xe1, 0xf5, 0x69,
  0x4e, 0x7b, 0x8d, 0x83, 0x8e, 0xf5, 0x97, 0x46, 0x36, 0xa1, 0x32, 0x4b,
  0xa1, 0x69, 0xf6, 0x61, 0xc6, 0xcf, 0x48, 0x55, 0x4e, 0x11, 0xe2, 0xa4,
  0x53, 0x8e, 0xe6, 0xa6, 0x33, 0x33, 0xb9, 0xc1, 0xc7, 0xa7, 0x4c, 0xc6,
  0x69, 0x6f, 0x52, 0x77, 0x38, 0x59, 0x6a, 0x55, 0xb0, 0x99, 0xb8, 0x0a,
  0xab, 0x68, 0xa3, 0x79, 0xc2, 0x1b, 0xb8, 0x51, 0xc5, 0x35, 0xe7, 0x58,
  0x4e, 0x4f, 0xf4, 0xdc, 0xae, 0xde, 0x68, 0x07, 0x23, 0x56, 0x10, 0xfc,
  0x7b, 0x4a, 0x0e, 0x24, 0x89, 0x9e, 0x2c, 0xe2, 0xfa, 0x0c, 0x01, 0x62,
  0xbc, 0x0d, 0x4b, 0x52, 0x74, 0xa0, 0x5e, 0xc7, 0x46, 0x3c, 0x3b, 0x43,
  0xce, 0x12, 0x12, 0xb0, 0x23, 0xd3, 0xbb, 0xe7, 0x0b, 0xd6, 0x3d, 0x32,
  0x3f, 0xa1, 0xc1, 0xbc, 0xb7, 0x80, 0xc9, 0xbf, 0x24, 0x68, 0x25, 0x89,
  0xd3, 0x94, 0x6d, 0x89, 0x52, 0xd1, 0x00, 0xd3, 0x47, 0x42, 0x7f, 0xe4,
  0x78, 0x76, 0xa3, 0x25, 0x8a, 0x4c, 0xc2, 0x71, 0x04, 0x6c, 0x97, 0x46,
  0x72, 0xa3, 0x77, 0xc2, 0x17, 0xc9, 0xa0, 0x65, 0x5b, 0x67, 0xa8, 0xac,
  0x11, 0xfd, 0x91, 0x40, 0x9d, 0x29, 0x61, 0x19, 0xcf, 0xee, 0xe1, 0x8b,
  0x5b, 0x7c, 0x06, 0x90, 0xb5, 0xb1, 0x7d, 0xdb, 0x68, 0xf2, 0xe1, 0x11,
  0xf0, 0x75, 0x43, 0xc7, 0xb7, 0xd9, 0xa5, 0xeb, 0xcb, 0x22, 0xa1, 0x9d,
  0xd4, 0xea, 0x12, 0x12, 0x2d, 0xdc, 0x20, 0x95, 0xd6, 0x04, 0x08, 0xf1,
  0xd1, 0x32, 0xf3, 0xce, 0x1b, 0x5b, 0xe9, 0xa7, 0x88, 0xc4, 0x12, 0x56,
  0x42, 0xa1, 0xd3, 0x86, 0xd9, 0x0a, 0x76
};
unsigned int cert_der_len = 895;

SSL_CTX *create_ssl_context()
{
    SSL_CTX *ctx = SSL_CTX_new(TLS_server_method());
    if (!ctx) {
        perror("Unable to create SSL context");
        ERR_print_errors_fp(stderr);
        exit(EXIT_FAILURE);
    }

    /* Set the key and cert */
    if (SSL_CTX_use_certificate_ASN1(ctx, cert_der_len, cert_der) <= 0) {
        ERR_print_errors_fp(stderr);
        exit(EXIT_FAILURE);
    }

    if (SSL_CTX_use_RSAPrivateKey_ASN1(ctx, key_der, key_der_len) <= 0 ) {
        ERR_print_errors_fp(stderr);
        exit(EXIT_FAILURE);
    }

    return ctx;
}

/* iperf_tcp_recv
 *
 * receives the data for TCP
 */
int
iperf_tcp_recv(struct iperf_stream *sp)
{
    int r;

    if (!sp->ssl) {
        assert(!sp->ssl_ctx);
        sp->ssl_ctx = create_ssl_context();
        sp->ssl = SSL_new(sp->ssl_ctx);
        SSL_set_fd(sp->ssl, sp->socket);
        if (SSL_accept(sp->ssl) <= 0) {
            ERR_print_errors_fp(stderr);
        }
    }
    r = ssl_nread(sp->ssl, sp->buffer, sp->settings->blksize, Ptcp);

    if (r < 0)
        return r;

    /* Only count bytes received while we're in the correct state. */
    if (sp->test->state == TEST_RUNNING) {
	sp->result->bytes_received += r;
	sp->result->bytes_received_this_interval += r;
    }
    else {
	if (sp->test->debug)
	    printf("Late receive, state = %d\n", sp->test->state);
    }

    return r;
}


/* iperf_tcp_send 
 *
 * sends the data for TCP
 */
int
iperf_tcp_send(struct iperf_stream *sp)
{
    int r;

    if (!sp->ssl) {
      assert(!sp->ssl_ctx);
      sp->ssl_ctx = SSL_CTX_new(TLS_client_method());   /* Create new context */
      if (sp->ssl_ctx == NULL) {
          ERR_print_errors_fp(stderr);
          return -1;
      }
      sp->ssl = SSL_new(sp->ssl_ctx);
      SSL_set_fd(sp->ssl, sp->socket);
      if (SSL_connect(sp->ssl) == -1) {
          ERR_print_errors_fp(stderr);
          return -1;
      }
    }

    if (sp->test->zerocopy)
	r = Nsendfile(sp->buffer_fd, sp->socket, sp->buffer, sp->settings->blksize);
    else
	r = ssl_nwrite(sp->ssl, sp->buffer, sp->settings->blksize, Ptcp);

    if (r < 0)
        return r;

    sp->result->bytes_sent += r;
    sp->result->bytes_sent_this_interval += r;

    if (sp->test->debug)
	printf("sent %d bytes of %d, total %" PRIu64 "\n", r, sp->settings->blksize, sp->result->bytes_sent);

    return r;
}


/* iperf_tcp_accept
 *
 * accept a new TCP stream connection
 */
int
iperf_tcp_accept(struct iperf_test * test)
{
    int     s;
    signed char rbuf = ACCESS_DENIED;
    char    cookie[COOKIE_SIZE];
    socklen_t len;
    struct sockaddr_storage addr;

    len = sizeof(addr);
    if ((s = accept(test->listener, (struct sockaddr *) &addr, &len)) < 0) {
        i_errno = IESTREAMCONNECT;
        return -1;
    }

    if (Nread(s, cookie, COOKIE_SIZE, Ptcp) < 0) {
        i_errno = IERECVCOOKIE;
        return -1;
    }

    if (strcmp(test->cookie, cookie) != 0) {
        if (Nwrite(s, (char*) &rbuf, sizeof(rbuf), Ptcp) < 0) {
            i_errno = IESENDMESSAGE;
            return -1;
        }
        close(s);
    }

    return s;
}


/* iperf_tcp_listen
 *
 * start up a listener for TCP stream connections
 */
int
iperf_tcp_listen(struct iperf_test *test)
{
    int s, opt;
    socklen_t optlen;
    int saved_errno;
    int rcvbuf_actual, sndbuf_actual;

    s = test->listener;

    /*
     * If certain parameters are specified (such as socket buffer
     * size), then throw away the listening socket (the one for which
     * we just accepted the control connection) and recreate it with
     * those parameters.  That way, when new data connections are
     * set, they'll have all the correct parameters in place.
     *
     * It's not clear whether this is a requirement or a convenience.
     */
    if (test->no_delay || test->settings->mss || test->settings->socket_bufsize) {
	struct addrinfo hints, *res;
	char portstr[6];

        FD_CLR(s, &test->read_set);
        close(s);

        snprintf(portstr, 6, "%d", test->server_port);
        memset(&hints, 0, sizeof(hints));

	/*
	 * If binding to the wildcard address with no explicit address
	 * family specified, then force us to get an AF_INET6 socket.
	 * More details in the comments in netanounce().
	 */
	if (test->settings->domain == AF_UNSPEC && !test->bind_address) {
	    hints.ai_family = AF_INET6;
	}
	else {
	    hints.ai_family = test->settings->domain;
	}
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_flags = AI_PASSIVE;
        if ((gerror = getaddrinfo(test->bind_address, portstr, &hints, &res)) != 0) {
            i_errno = IESTREAMLISTEN;
            return -1;
        }

        if ((s = socket(res->ai_family, SOCK_STREAM, 0)) < 0) {
	    freeaddrinfo(res);
            i_errno = IESTREAMLISTEN;
            return -1;
        }

        if (test->no_delay) {
            opt = 1;
            if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt)) < 0) {
		saved_errno = errno;
		close(s);
		freeaddrinfo(res);
		errno = saved_errno;
                i_errno = IESETNODELAY;
                return -1;
            }
        }
        // XXX: Setting MSS is very buggy!
        if ((opt = test->settings->mss)) {
            if (setsockopt(s, IPPROTO_TCP, TCP_MAXSEG, &opt, sizeof(opt)) < 0) {
		saved_errno = errno;
		close(s);
		freeaddrinfo(res);
		errno = saved_errno;
                i_errno = IESETMSS;
                return -1;
            }
        }
        if ((opt = test->settings->socket_bufsize)) {
            if (setsockopt(s, SOL_SOCKET, SO_RCVBUF, &opt, sizeof(opt)) < 0) {
		saved_errno = errno;
		close(s);
		freeaddrinfo(res);
		errno = saved_errno;
                i_errno = IESETBUF;
                return -1;
            }
            if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, &opt, sizeof(opt)) < 0) {
		saved_errno = errno;
		close(s);
		freeaddrinfo(res);
		errno = saved_errno;
                i_errno = IESETBUF;
                return -1;
            }
        }
#if defined(HAVE_SO_MAX_PACING_RATE)
    /* If fq socket pacing is specified, enable it. */
    if (test->settings->fqrate) {
	/* Convert bits per second to bytes per second */
	unsigned int fqrate = test->settings->fqrate / 8;
	if (fqrate > 0) {
	    if (test->debug) {
		printf("Setting fair-queue socket pacing to %u\n", fqrate);
	    }
	    if (setsockopt(s, SOL_SOCKET, SO_MAX_PACING_RATE, &fqrate, sizeof(fqrate)) < 0) {
		warning("Unable to set socket pacing");
	    }
	}
    }
#endif /* HAVE_SO_MAX_PACING_RATE */
    {
	unsigned int rate = test->settings->rate / 8;
	if (rate > 0) {
	    if (test->debug) {
		printf("Setting application pacing to %u\n", rate);
	    }
	}
    }
        opt = 1;
        if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
	    saved_errno = errno;
            close(s);
	    freeaddrinfo(res);
	    errno = saved_errno;
            i_errno = IEREUSEADDR;
            return -1;
        }

	/*
	 * If we got an IPv6 socket, figure out if it shoudl accept IPv4
	 * connections as well.  See documentation in netannounce() for
	 * more details.
	 */
#if defined(IPV6_V6ONLY) && !defined(__OpenBSD__)
	if (res->ai_family == AF_INET6 && (test->settings->domain == AF_UNSPEC || test->settings->domain == AF_INET)) {
	    if (test->settings->domain == AF_UNSPEC)
		opt = 0;
	    else 
		opt = 1;
	    if (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, 
			   (char *) &opt, sizeof(opt)) < 0) {
		saved_errno = errno;
		close(s);
		freeaddrinfo(res);
		errno = saved_errno;
		i_errno = IEV6ONLY;
		return -1;
	    }
	}
#endif /* IPV6_V6ONLY */

        if (bind(s, (struct sockaddr *) res->ai_addr, res->ai_addrlen) < 0) {
	    saved_errno = errno;
            close(s);
	    freeaddrinfo(res);
	    errno = saved_errno;
            i_errno = IESTREAMLISTEN;
            return -1;
        }

        freeaddrinfo(res);

        if (listen(s, INT_MAX) < 0) {
            i_errno = IESTREAMLISTEN;
            return -1;
        }

        test->listener = s;
    }
    
    /* Read back and verify the sender socket buffer size */
    optlen = sizeof(sndbuf_actual);
    if (getsockopt(s, SOL_SOCKET, SO_SNDBUF, &sndbuf_actual, &optlen) < 0) {
	saved_errno = errno;
	close(s);
	errno = saved_errno;
	i_errno = IESETBUF;
	return -1;
    }
    if (test->debug) {
	printf("SNDBUF is %u, expecting %u\n", sndbuf_actual, test->settings->socket_bufsize);
    }
    if (test->settings->socket_bufsize && test->settings->socket_bufsize > sndbuf_actual) {
	i_errno = IESETBUF2;
	return -1;
    }

    /* Read back and verify the receiver socket buffer size */
    optlen = sizeof(rcvbuf_actual);
    if (getsockopt(s, SOL_SOCKET, SO_RCVBUF, &rcvbuf_actual, &optlen) < 0) {
	saved_errno = errno;
	close(s);
	errno = saved_errno;
	i_errno = IESETBUF;
	return -1;
    }
    if (test->debug) {
	printf("RCVBUF is %u, expecting %u\n", rcvbuf_actual, test->settings->socket_bufsize);
    }
    if (test->settings->socket_bufsize && test->settings->socket_bufsize > rcvbuf_actual) {
	i_errno = IESETBUF2;
	return -1;
    }

    if (test->json_output) {
	cJSON_AddNumberToObject(test->json_start, "sock_bufsize", test->settings->socket_bufsize);
	cJSON_AddNumberToObject(test->json_start, "sndbuf_actual", sndbuf_actual);
	cJSON_AddNumberToObject(test->json_start, "rcvbuf_actual", rcvbuf_actual);
    }

    return s;
}


/* iperf_tcp_connect
 *
 * connect to a TCP stream listener
 * This function is roughly similar to netdial(), and may indeed have
 * been derived from it at some point, but it sets many TCP-specific
 * options between socket creation and connection.
 */
int
iperf_tcp_connect(struct iperf_test *test)
{
    struct addrinfo hints, *local_res, *server_res;
    char portstr[6];
    int s, opt;
    socklen_t optlen;
    int saved_errno;
    int rcvbuf_actual, sndbuf_actual;

    if (test->bind_address) {
        memset(&hints, 0, sizeof(hints));
        hints.ai_family = test->settings->domain;
        hints.ai_socktype = SOCK_STREAM;
        if ((gerror = getaddrinfo(test->bind_address, NULL, &hints, &local_res)) != 0) {
            i_errno = IESTREAMCONNECT;
            return -1;
        }
    }

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = test->settings->domain;
    hints.ai_socktype = SOCK_STREAM;
    snprintf(portstr, sizeof(portstr), "%d", test->server_port);
    if ((gerror = getaddrinfo(test->server_hostname, portstr, &hints, &server_res)) != 0) {
	if (test->bind_address)
	    freeaddrinfo(local_res);
        i_errno = IESTREAMCONNECT;
        return -1;
    }

    if ((s = socket(server_res->ai_family, SOCK_STREAM, 0)) < 0) {
	if (test->bind_address)
	    freeaddrinfo(local_res);
	freeaddrinfo(server_res);
        i_errno = IESTREAMCONNECT;
        return -1;
    }

    /*
     * Various ways to bind the local end of the connection.
     * 1.  --bind (with or without --cport).
     */
    if (test->bind_address) {
        struct sockaddr_in *lcladdr;
        lcladdr = (struct sockaddr_in *)local_res->ai_addr;
        lcladdr->sin_port = htons(test->bind_port);

        if (bind(s, (struct sockaddr *) local_res->ai_addr, local_res->ai_addrlen) < 0) {
	    saved_errno = errno;
	    close(s);
	    freeaddrinfo(local_res);
	    freeaddrinfo(server_res);
	    errno = saved_errno;
            i_errno = IESTREAMCONNECT;
            return -1;
        }
        freeaddrinfo(local_res);
    }
    /* --cport, no --bind */
    else if (test->bind_port) {
	size_t addrlen;
	struct sockaddr_storage lcl;

	/* IPv4 */
	if (server_res->ai_family == AF_INET) {
	    struct sockaddr_in *lcladdr = (struct sockaddr_in *) &lcl;
	    lcladdr->sin_family = AF_INET;
	    lcladdr->sin_port = htons(test->bind_port);
	    lcladdr->sin_addr.s_addr = INADDR_ANY;
	    addrlen = sizeof(struct sockaddr_in);
	}
	/* IPv6 */
	else if (server_res->ai_family == AF_INET6) {
	    struct sockaddr_in6 *lcladdr = (struct sockaddr_in6 *) &lcl;
	    lcladdr->sin6_family = AF_INET6;
	    lcladdr->sin6_port = htons(test->bind_port);
	    lcladdr->sin6_addr = in6addr_any;
	    addrlen = sizeof(struct sockaddr_in6);
	}
	/* Unknown protocol */
	else {
	    saved_errno = errno;
	    close(s);
	    freeaddrinfo(server_res);
	    errno = saved_errno;
            i_errno = IEPROTOCOL;
            return -1;
	}

        if (bind(s, (struct sockaddr *) &lcl, addrlen) < 0) {
	    saved_errno = errno;
	    close(s);
	    freeaddrinfo(server_res);
	    errno = saved_errno;
            i_errno = IESTREAMCONNECT;
            return -1;
        }
    }

    /* Set socket options */
    if (test->no_delay) {
        opt = 1;
        if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt)) < 0) {
	    saved_errno = errno;
	    close(s);
	    freeaddrinfo(server_res);
	    errno = saved_errno;
            i_errno = IESETNODELAY;
            return -1;
        }
    }
    if ((opt = test->settings->mss)) {
        if (setsockopt(s, IPPROTO_TCP, TCP_MAXSEG, &opt, sizeof(opt)) < 0) {
	    saved_errno = errno;
	    close(s);
	    freeaddrinfo(server_res);
	    errno = saved_errno;
            i_errno = IESETMSS;
            return -1;
        }
    }
    if ((opt = test->settings->socket_bufsize)) {
        if (setsockopt(s, SOL_SOCKET, SO_RCVBUF, &opt, sizeof(opt)) < 0) {
	    saved_errno = errno;
	    close(s);
	    freeaddrinfo(server_res);
	    errno = saved_errno;
            i_errno = IESETBUF;
            return -1;
        }
        if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, &opt, sizeof(opt)) < 0) {
	    saved_errno = errno;
	    close(s);
	    freeaddrinfo(server_res);
	    errno = saved_errno;
            i_errno = IESETBUF;
            return -1;
        }
    }

    /* Read back and verify the sender socket buffer size */
    optlen = sizeof(sndbuf_actual);
    if (getsockopt(s, SOL_SOCKET, SO_SNDBUF, &sndbuf_actual, &optlen) < 0) {
	saved_errno = errno;
	close(s);
	freeaddrinfo(server_res);
	errno = saved_errno;
	i_errno = IESETBUF;
	return -1;
    }
    if (test->debug) {
	printf("SNDBUF is %u, expecting %u\n", sndbuf_actual, test->settings->socket_bufsize);
    }
    if (test->settings->socket_bufsize && test->settings->socket_bufsize > sndbuf_actual) {
	i_errno = IESETBUF2;
	return -1;
    }

    /* Read back and verify the receiver socket buffer size */
    optlen = sizeof(rcvbuf_actual);
    if (getsockopt(s, SOL_SOCKET, SO_RCVBUF, &rcvbuf_actual, &optlen) < 0) {
	saved_errno = errno;
	close(s);
	freeaddrinfo(server_res);
	errno = saved_errno;
	i_errno = IESETBUF;
	return -1;
    }
    if (test->debug) {
	printf("RCVBUF is %u, expecting %u\n", rcvbuf_actual, test->settings->socket_bufsize);
    }
    if (test->settings->socket_bufsize && test->settings->socket_bufsize > rcvbuf_actual) {
	i_errno = IESETBUF2;
	return -1;
    }

    if (test->json_output) {
	cJSON_AddNumberToObject(test->json_start, "sock_bufsize", test->settings->socket_bufsize);
	cJSON_AddNumberToObject(test->json_start, "sndbuf_actual", sndbuf_actual);
	cJSON_AddNumberToObject(test->json_start, "rcvbuf_actual", rcvbuf_actual);
    }

#if defined(HAVE_FLOWLABEL)
    if (test->settings->flowlabel) {
        if (server_res->ai_addr->sa_family != AF_INET6) {
	    saved_errno = errno;
	    close(s);
	    freeaddrinfo(server_res);
	    errno = saved_errno;
            i_errno = IESETFLOW;
            return -1;
	} else {
	    struct sockaddr_in6* sa6P = (struct sockaddr_in6*) server_res->ai_addr;
            char freq_buf[sizeof(struct in6_flowlabel_req)];
            struct in6_flowlabel_req *freq = (struct in6_flowlabel_req *)freq_buf;
            int freq_len = sizeof(*freq);

            memset(freq, 0, sizeof(*freq));
            freq->flr_label = htonl(test->settings->flowlabel & IPV6_FLOWINFO_FLOWLABEL);
            freq->flr_action = IPV6_FL_A_GET;
            freq->flr_flags = IPV6_FL_F_CREATE;
            freq->flr_share = IPV6_FL_S_ANY;
            memcpy(&freq->flr_dst, &sa6P->sin6_addr, 16);

            if (setsockopt(s, IPPROTO_IPV6, IPV6_FLOWLABEL_MGR, freq, freq_len) < 0) {
		saved_errno = errno;
                close(s);
                freeaddrinfo(server_res);
		errno = saved_errno;
                i_errno = IESETFLOW;
                return -1;
            }
            sa6P->sin6_flowinfo = freq->flr_label;

            opt = 1;
            if (setsockopt(s, IPPROTO_IPV6, IPV6_FLOWINFO_SEND, &opt, sizeof(opt)) < 0) {
		saved_errno = errno;
                close(s);
                freeaddrinfo(server_res);
		errno = saved_errno;
                i_errno = IESETFLOW;
                return -1;
            } 
	}
    }
#endif /* HAVE_FLOWLABEL */

#if defined(HAVE_SO_MAX_PACING_RATE)
    /* If socket pacing is specified try to enable it. */
    if (test->settings->fqrate) {
	/* Convert bits per second to bytes per second */
	unsigned int fqrate = test->settings->fqrate / 8;
	if (fqrate > 0) {
	    if (test->debug) {
		printf("Setting fair-queue socket pacing to %u\n", fqrate);
	    }
	    if (setsockopt(s, SOL_SOCKET, SO_MAX_PACING_RATE, &fqrate, sizeof(fqrate)) < 0) {
		warning("Unable to set socket pacing");
	    }
	}
    }
#endif /* HAVE_SO_MAX_PACING_RATE */
    {
	unsigned int rate = test->settings->rate / 8;
	if (rate > 0) {
	    if (test->debug) {
		printf("Setting application pacing to %u\n", rate);
	    }
	}
    }

    if (connect(s, (struct sockaddr *) server_res->ai_addr, server_res->ai_addrlen) < 0 && errno != EINPROGRESS) {
	saved_errno = errno;
	close(s);
	freeaddrinfo(server_res);
	errno = saved_errno;
        i_errno = IESTREAMCONNECT;
        return -1;
    }

    freeaddrinfo(server_res);

    /* Send cookie for verification */
    if (Nwrite(s, test->cookie, COOKIE_SIZE, Ptcp) < 0) {
	saved_errno = errno;
	close(s);
	errno = saved_errno;
        i_errno = IESENDCOOKIE;
        return -1;
    }

    return s;
}
